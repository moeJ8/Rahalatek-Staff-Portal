const OfficePayment = require('../models/OfficePayment');
const { invalidateDashboardCache } = require('../utils/redis');
const OfficeDetailPdfService = require('../services/officeDetailPdfService');
const PaymentReceiptService = require('../services/paymentReceiptService');
const User = require('../models/User');

// Get all payments across offices with optional filters
exports.getAllOfficePayments = async (req, res) => {
    try {
        const {
            type,
            status,
            currency,
            officeName,
            createdBy,
            voucherId,
            voucherNumber,
            minAmount,
            maxAmount,
            startDate,
            endDate,
            autoGenerated
        } = req.query;

        const filter = {};

        if (type) {
            filter.type = type.toUpperCase();
        }

        if (status) {
            filter.status = status.toLowerCase();
        }

        if (currency) {
            filter.currency = currency.toUpperCase();
        }

        if (officeName) {
            filter.officeName = officeName;
        }

        if (createdBy) {
            filter.createdBy = createdBy;
        }

        if (voucherId) {
            filter.relatedVoucher = voucherId;
        }

        if (autoGenerated === 'true') {
            filter.autoGenerated = true;
        } else if (autoGenerated === 'false') {
            filter.autoGenerated = false;
        }

        if (minAmount || maxAmount) {
            filter.amount = {};
            if (minAmount) filter.amount.$gte = Number(minAmount);
            if (maxAmount) filter.amount.$lte = Number(maxAmount);
        }

        if (startDate || endDate) {
            filter.createdAt = {};
            if (startDate) filter.createdAt.$gte = new Date(startDate);
            if (endDate) {
                const end = new Date(endDate);
                end.setHours(23, 59, 59, 999);
                filter.createdAt.$lte = end;
            }
        }

        let payments = await OfficePayment.find(filter)
            .populate('createdBy', 'name username')
            .populate('approvedBy', 'name username')
            .populate('relatedVoucher', 'voucherNumber clientName officeName currency')
            .sort({ createdAt: -1 })
            .lean();

        if (voucherNumber) {
            payments = payments.filter(payment =>
                payment.relatedVoucher &&
                payment.relatedVoucher.voucherNumber &&
                payment.relatedVoucher.voucherNumber.toString() === voucherNumber.toString()
            );
        }

        res.status(200).json({
            success: true,
            count: payments.length,
            data: payments
        });
    } catch (error) {
        console.error('Error fetching office payments list:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to fetch payments',
            error: error.message
        });
    }
};

// Get all payments for an office by currency
exports.getOfficePayments = async (req, res) => {
    try {
        const { officeName } = req.params;
        const { currency } = req.query;

        if (!officeName) {
            return res.status(400).json({ message: 'Office name is required' });
        }

        const query = { officeName: decodeURIComponent(officeName) };
        if (currency) {
            query.currency = currency;
        }

        const payments = await OfficePayment.find(query)
            .populate('createdBy', 'name')
            .populate('relatedVoucher', 'voucherNumber clientName')
            .sort({ createdAt: -1 });

        res.json(payments);
    } catch (error) {
        console.error('Error fetching office payments:', error);
        res.status(500).json({ message: 'Server error' });
    }
};

// Get relevant vouchers for an office (optimized endpoint)
exports.getOfficeVouchers = async (req, res) => {
    try {
        const { officeName } = req.params;
        const decodedOfficeName = decodeURIComponent(officeName);

        if (!decodedOfficeName) {
            return res.status(400).json({ 
                success: false,
                message: 'Office name is required' 
            });
        }

        console.time(`getOfficeVouchers-${decodedOfficeName}`);

        const Voucher = require('../models/Voucher');

        // Build optimized query to find vouchers where this office is involved
        // Either as client (voucher.officeName) OR as service provider (in arrays)
        const vouchers = await Voucher.find({
            $and: [
                // Not deleted
                {
                    $or: [
                        { isDeleted: false },
                        { isDeleted: { $exists: false } }
                    ]
                },
                // Office is involved
                {
                    $or: [
                        // Office is the client
                        { officeName: decodedOfficeName },
                        // Office provided hotel services
                        { 'hotels.officeName': decodedOfficeName },
                        // Office provided transfer services
                        { 'transfers.officeName': decodedOfficeName },
                        // Office provided trip services (new structure)
                        { 'trips.officeName': decodedOfficeName },
                        // Office provided trip services (old structure)
                        { 'payments.trips.officeName': decodedOfficeName },
                        // Office provided flight services
                        { 'flights.officeName': decodedOfficeName },
                        // Office provided other services
                        { 'others.officeName': decodedOfficeName }
                    ]
                }
            ]
        })
        .populate('createdBy', 'username')
        .populate('statusUpdatedBy', 'username')
        .sort({ createdAt: -1 })
        .lean();

        // Get all office payments for these vouchers
        const voucherIds = vouchers.map(v => v._id);
        const officePayments = await OfficePayment.find({ 
            relatedVoucher: { $in: voucherIds },
            officeName: decodedOfficeName
        }).lean();

        // Map office payments to vouchers
        const vouchersWithPayments = vouchers.map(voucher => {
            const voucherPayments = officePayments.filter(payment => 
                payment.relatedVoucher && payment.relatedVoucher.toString() === voucher._id.toString()
            );
            return {
                ...voucher,
                officePayments: voucherPayments
            };
        });

        console.timeEnd(`getOfficeVouchers-${decodedOfficeName}`);
        console.log(`ðŸ“Š Found ${vouchersWithPayments.length} relevant vouchers for ${decodedOfficeName}`);

        res.status(200).json({
            success: true,
            count: vouchersWithPayments.length,
            data: vouchersWithPayments
        });

    } catch (error) {
        console.error('Error fetching office vouchers:', error);
        res.status(500).json({ 
            success: false,
            message: 'Server error',
            error: error.message 
        });
    }
};

// Create a new office payment
exports.createOfficePayment = async (req, res) => {
    try {
        const { type, amount, currency, notes, officeName, voucherId, paymentDate } = req.body;

        if (!type || !amount || !currency || !officeName) {
            return res.status(400).json({ 
                message: 'Type, amount, currency, and office name are required' 
            });
        }

        if (!['INCOMING', 'OUTGOING'].includes(type)) {
            return res.status(400).json({ 
                message: 'Type must be either INCOMING or OUTGOING' 
            });
        }

        if (amount <= 0) {
            return res.status(400).json({ 
                message: 'Amount must be greater than 0' 
            });
        }

        const paymentData = {
            type,
            amount,
            currency,
            notes: notes || '',
            officeName,
            createdBy: req.user.userId
        };

        // Add voucher relation if provided
        if (voucherId) {
            paymentData.relatedVoucher = voucherId;
        }

        // Add payment date if provided
        if (paymentDate) {
            paymentData.paymentDate = new Date(paymentDate);
        }

        const payment = new OfficePayment(paymentData);

        const savedPayment = await payment.save();
        const populatedPayment = await OfficePayment.findById(savedPayment._id)
            .populate('createdBy', 'name')
            .populate('relatedVoucher', 'voucherNumber clientName');

        // Smart cache invalidation - financial data changed
        await invalidateDashboardCache('Office payment created');

        res.status(201).json(populatedPayment);
    } catch (error) {
        console.error('Error creating office payment:', error);
        res.status(500).json({ message: 'Server error' });
    }
};

// Delete an office payment
exports.deleteOfficePayment = async (req, res) => {
    try {
        const { paymentId } = req.params;

        if (!paymentId) {
            return res.status(400).json({ message: 'Payment ID is required' });
        }

        const payment = await OfficePayment.findById(paymentId);
        if (!payment) {
            return res.status(404).json({ message: 'Payment not found' });
        }

        await OfficePayment.findByIdAndDelete(paymentId);

        // Smart cache invalidation - financial data changed
        await invalidateDashboardCache('Office payment deleted');

        res.json({ message: 'Payment deleted successfully' });
    } catch (error) {
        console.error('Error deleting office payment:', error);
        res.status(500).json({ message: 'Server error' });
    }
};

// Approve an office payment (Admin/Accountant only)
exports.approveOfficePayment = async (req, res) => {
    try {
        const { paymentId } = req.params;

        if (!paymentId) {
            return res.status(400).json({ message: 'Payment ID is required' });
        }

        // Check if user is admin or accountant
        if (!req.user.isAdmin && !req.user.isAccountant) {
            return res.status(403).json({ 
                message: 'Only administrators and accountants can approve payments' 
            });
        }

        const payment = await OfficePayment.findById(paymentId);
        if (!payment) {
            return res.status(404).json({ message: 'Payment not found' });
        }

        if (payment.status !== 'pending') {
            return res.status(400).json({ 
                message: 'Only pending payments can be approved' 
            });
        }

        const updateData = {
            status: 'approved',
            approvedBy: req.user.userId,
            approvedAt: new Date()
        };

        // If payment date is provided, update it
        if (req.body.paymentDate) {
            updateData.paymentDate = new Date(req.body.paymentDate);
        }

        const updatedPayment = await OfficePayment.findByIdAndUpdate(
            paymentId,
            updateData,
            { new: true }
        )
        .populate('createdBy', 'name')
        .populate('relatedVoucher', 'voucherNumber clientName')
        .populate('approvedBy', 'name');

        // If the payment is linked to a voucher and has a payment date, update the voucher's payment date
        if (updatedPayment.relatedVoucher && updateData.paymentDate) {
            const Voucher = require('../models/Voucher');
            await Voucher.findByIdAndUpdate(
                updatedPayment.relatedVoucher._id,
                { paymentDate: updateData.paymentDate }
            );
        }

        // Smart cache invalidation - financial data changed
        await invalidateDashboardCache('Office payment updated');

        res.json(updatedPayment);
    } catch (error) {
        console.error('Error approving office payment:', error);
        res.status(500).json({ message: 'Server error' });
    }
}; 

// Update payment date for an office payment (Admin/Accountant only)
exports.updatePaymentDate = async (req, res) => {
    try {
        const { paymentId } = req.params;
        const { paymentDate } = req.body;

        if (!paymentId) {
            return res.status(400).json({ message: 'Payment ID is required' });
        }

        if (!paymentDate) {
            return res.status(400).json({ message: 'Payment date is required' });
        }

        // Check if user is admin or accountant
        if (!req.user.isAdmin && !req.user.isAccountant) {
            return res.status(403).json({ 
                message: 'Only administrators and accountants can update payment dates' 
            });
        }

        const payment = await OfficePayment.findById(paymentId);
        if (!payment) {
            return res.status(404).json({ message: 'Payment not found' });
        }

        const updatedPayment = await OfficePayment.findByIdAndUpdate(
            paymentId,
            { paymentDate: new Date(paymentDate) },
            { new: true }
        )
        .populate('createdBy', 'name')
        .populate('relatedVoucher', 'voucherNumber clientName')
        .populate('approvedBy', 'name');

        // If the payment is linked to a voucher, also update the voucher's payment date
        if (updatedPayment.relatedVoucher) {
            const Voucher = require('../models/Voucher');
            await Voucher.findByIdAndUpdate(
                updatedPayment.relatedVoucher._id,
                { paymentDate: new Date(paymentDate) }
            );
        }

        res.json(updatedPayment);
    } catch (error) {
        console.error('Error updating payment date:', error);
        res.status(500).json({ message: 'Server error' });
    }
};

// Download office detail as PDF
exports.downloadOfficeDetailPDF = async (req, res) => {
    try {
        const { officeName } = req.params;
        const { year, month, arrivalMonth, currency } = req.query;
        
        if (!officeName) {
            return res.status(400).json({ 
                success: false,
                message: 'Office name is required' 
            });
        }
        
        // Get full user object
        const fullUser = await User.findById(req.user.userId).select('username email isAdmin isAccountant');
        
        if (!fullUser) {
            return res.status(404).json({
                success: false,
                message: 'User not found'
            });
        }
        
        // Parse filters
        const filters = {
            year: year || new Date().getFullYear().toString(),
            month: month ? JSON.parse(month) : [''],
            arrivalMonth: arrivalMonth ? JSON.parse(arrivalMonth) : [],
            currency: currency || 'ALL'
        };
        
        // Generate office detail data
        const officeData = await OfficeDetailPdfService.generateOfficeDetailData(
            decodeURIComponent(officeName), 
            filters
        );
        
        // Generate PDF
        const pdfBuffer = await OfficeDetailPdfService.generateOfficeDetailPDF(officeData, fullUser);
        
        // Set response headers for PDF download
        const filename = `office-detail-${officeName.replace(/[^a-z0-9]/gi, '-')}-${filters.year}.pdf`;
        
        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
        res.setHeader('Content-Length', pdfBuffer.length);
        
        // Send PDF
        res.end(pdfBuffer);
        
    } catch (error) {
        console.error('Error downloading office detail PDF:', error);
        res.status(500).json({ 
            success: false,
            message: 'Failed to generate PDF',
            error: error.message 
        });
    }
}; 

// Download single payment receipt PDF
exports.downloadPaymentReceipt = async (req, res) => {
    try {
        const { paymentId } = req.params;

        if (!paymentId) {
            return res.status(400).json({
                success: false,
                message: 'Payment ID is required'
            });
        }

        const payment = await OfficePayment.findById(paymentId)
            .populate('createdBy', 'name username email')
            .populate('approvedBy', 'name username email')
            .populate('relatedVoucher', 'voucherNumber clientName arrivalDate departureDate officeName');

        if (!payment) {
            return res.status(404).json({
                success: false,
                message: 'Payment not found'
            });
        }

        if (payment.status !== 'approved') {
            return res.status(400).json({
                success: false,
                message: 'Receipts are only available for approved payments'
            });
        }

        const requestingUser = await User.findById(req.user.userId).select('name username email');

        const pdfBuffer = await PaymentReceiptService.generatePaymentReceipt(payment, requestingUser);

        const sanitizedOffice = (payment.officeName || 'office')
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/(^-|-$)/g, '');

        const filename = `payment-receipt-${payment._id}-${sanitizedOffice || 'office'}.pdf`;

        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
        res.setHeader('Content-Length', pdfBuffer.length);

        return res.end(pdfBuffer);
    } catch (error) {
        console.error('Error generating payment receipt:', error);
        return res.status(500).json({
            success: false,
            message: 'Failed to generate payment receipt',
            error: error.message
        });
    }
};