const Voucher = require("../models/Voucher");
const OfficePayment = require("../models/OfficePayment");
const { invalidateDashboardCache } = require("../utils/redis");

// Helper function to manage automatic office payments for vouchers
const manageVoucherOfficePayment = async (
  voucher,
  oldVoucher = null,
  userId
) => {
  try {
    // Delete only PENDING auto-generated payments for this voucher
    // Approved payments should be preserved (they've been reviewed and finalized)
    await OfficePayment.deleteMany({
      relatedVoucher: voucher._id,
      autoGenerated: true,
      status: "pending",
    });

    // PRIORITY 1: Client-level office payment (main voucher payment)
    // If voucher has an officeName and totalAmount, create client payment
    if (
      voucher.officeName &&
      voucher.officeName.trim() !== "" &&
      voucher.totalAmount > 0
    ) {
      const clientPayment = new OfficePayment({
        type: "INCOMING",
        amount: voucher.totalAmount,
        currency: voucher.currency,
        notes: `Auto-generated client payment from Voucher #${voucher.voucherNumber} - ${voucher.clientName}. Total voucher amount.`,
        officeName: voucher.officeName,
        createdBy: userId,
        relatedVoucher: voucher._id,
        autoGenerated: true,
        status: "pending",
      });

      await clientPayment.save();
    }

    // PRIORITY 2: Service-level payments (for B2B scenarios)
    // Create service payments regardless of client-level office
    // This allows both client payments AND service payments to coexist
    const servicePayments = [];

    // Hotels
    if (voucher.hotels) {
      voucher.hotels.forEach((hotel, index) => {
        if (hotel.officeName && hotel.price > 0) {
          servicePayments.push({
            officeName: hotel.officeName,
            amount: hotel.price,
            serviceType: "hotel",
            serviceIndex: index,
            serviceDescription: `${hotel.hotelName || "Hotel"} - ${
              hotel.city || "N/A"
            }`,
          });
        }
      });
    }

    // Transfers
    if (voucher.transfers) {
      voucher.transfers.forEach((transfer, index) => {
        if (transfer.officeName && transfer.price > 0) {
          servicePayments.push({
            officeName: transfer.officeName,
            amount: transfer.price,
            serviceType: "transfer",
            serviceIndex: index,
            serviceDescription: `${transfer.type} Transfer - ${
              transfer.from || "N/A"
            } to ${transfer.to || "N/A"}`,
          });
        }
      });
    }

    // Trips - handle both individual trip payments and global payments.trips
    let tripsHandled = false;

    // First, try to extract individual trip payments if trips is an array with payment info
    if (voucher.trips && Array.isArray(voucher.trips)) {
      voucher.trips.forEach((trip, index) => {
        if (
          trip &&
          typeof trip === "object" &&
          trip.officeName &&
          trip.price > 0
        ) {
          servicePayments.push({
            officeName: trip.officeName,
            amount: trip.price,
            serviceType: "trip",
            serviceIndex: index,
            serviceDescription: `${trip.tourName || "Trip"} - ${
              trip.city || "N/A"
            }`,
          });
          tripsHandled = true;
        }
      });
    }

    // If no individual trip payments found, fall back to global payments.trips
    if (
      !tripsHandled &&
      voucher.payments &&
      voucher.payments.trips &&
      voucher.payments.trips.officeName &&
      voucher.payments.trips.price > 0
    ) {
      servicePayments.push({
        officeName: voucher.payments.trips.officeName,
        amount: voucher.payments.trips.price,
        serviceType: "trip",
        serviceIndex: 0,
        serviceDescription: "Trip Services",
      });
    }

    // Flights
    if (voucher.flights) {
      voucher.flights.forEach((flight, index) => {
        if (flight.officeName && flight.price > 0) {
          servicePayments.push({
            officeName: flight.officeName,
            amount: flight.price,
            serviceType: "flight",
            serviceIndex: index,
            serviceDescription: `${flight.companyName || "Flight"} - ${
              flight.from || "N/A"
            } to ${flight.to || "N/A"}`,
          });
        }
      });
    }

    // Others - handle per-item payments for generic services
    if (voucher.others && Array.isArray(voucher.others)) {
      voucher.others.forEach((other, index) => {
        if (
          other &&
          typeof other === "object" &&
          other.officeName &&
          other.price > 0
        ) {
          servicePayments.push({
            officeName: other.officeName,
            amount: other.price,
            serviceType: "other",
            serviceIndex: index,
            serviceDescription: other.description || "Other Service",
          });
        }
      });
    }

    // Group service payments by office to create consolidated payments
    const officeGroups = {};
    servicePayments.forEach((service) => {
      if (!officeGroups[service.officeName]) {
        officeGroups[service.officeName] = {
          totalAmount: 0,
          services: [],
        };
      }
      officeGroups[service.officeName].totalAmount += service.amount;
      officeGroups[service.officeName].services.push(service);
    });

    // Create service payments for each office
    for (const [officeName, groupData] of Object.entries(officeGroups)) {
      const serviceDescriptions = groupData.services
        .map((s) => s.serviceDescription)
        .join(", ");
      const notes = `Auto-generated service payment from Voucher #${voucher.voucherNumber} - ${voucher.clientName}. Services: ${serviceDescriptions}`;

      const payment = new OfficePayment({
        type: "OUTGOING",
        amount: groupData.totalAmount,
        currency: voucher.currency,
        notes: notes,
        officeName: officeName,
        createdBy: userId,
        relatedVoucher: voucher._id,
        autoGenerated: true,
        status: "pending",
      });

      await payment.save();
    }
  } catch (error) {
    console.error("Error managing voucher office payment:", error);
    // Don't throw error here - we don't want voucher creation/update to fail because of payment issues
  }
};

// Create a new voucher
exports.createVoucher = async (req, res) => {
  try {
    const {
      voucherNumber: providedVoucherNumber,
      clientName,
      nationality,
      phoneNumber,
      officeName,
      bookingReference,
      arrivalDate,
      departureDate,
      capital,
      hotels,
      transfers,
      trips,
      flights,
      others,
      note,
      privateNote,
      totalAmount,
      currency,
      advancedPayment,
      advancedAmount,
      remainingAmount,
      payments,
    } = req.body;

    let voucherNumber;
    if (providedVoucherNumber) {
      voucherNumber = providedVoucherNumber;
    } else {
      voucherNumber = await Voucher.getNextVoucherNumber();
    }

    const voucher = new Voucher({
      voucherNumber,
      voucherId: voucherNumber,
      bookingNumber: voucherNumber,
      clientName,
      nationality,
      phoneNumber: phoneNumber || "",
      officeName: officeName || "",
      bookingReference: bookingReference || "Auto-generated",
      arrivalDate,
      departureDate,
      capital: capital || "",
      currency: currency || "USD",
      hotels,
      transfers,
      trips,
      flights: flights || [],
      others: others || [],
      note: note || "",
      privateNote: privateNote || "",
      totalAmount: Number(totalAmount) || 0,
      advancedPayment: advancedPayment || false,
      advancedAmount: advancedPayment ? Number(advancedAmount) || 0 : 0,
      remainingAmount: advancedPayment ? Number(remainingAmount) || 0 : 0,
      payments: payments || {
        hotels: { officeName: "", price: 0 },
        transfers: { officeName: "", price: 0 },
        trips: { officeName: "", price: 0 },
        flights: { officeName: "", price: 0 },
        others: { officeName: "", price: 0 },
      },
      createdBy: req.user.userId,
    });

    await voucher.save();

    // Automatically create office payment for this voucher
    await manageVoucherOfficePayment(voucher, null, req.user.userId);

    // Smart cache invalidation - voucher data changed
    await invalidateDashboardCache("New voucher created");

    res.status(201).json({
      success: true,
      data: voucher,
    });
  } catch (error) {
    if (error.code === 11000) {
      try {
        const randomNumber = 10000 + Math.floor(Math.random() * 90000);

        const voucher = new Voucher({
          voucherNumber: randomNumber,
          voucherId: randomNumber,
          bookingNumber: randomNumber,
          clientName,
          nationality,
          phoneNumber: phoneNumber || "",
          officeName: officeName || "",
          bookingReference: bookingReference || "Auto-generated",
          arrivalDate,
          departureDate,
          capital: capital || "",
          currency: currency || "USD",
          hotels,
          transfers,
          trips,
          flights: flights || [],
          others: others || [],
          note: note || "",
          privateNote: privateNote || "",
          totalAmount: Number(totalAmount) || 0,
          advancedPayment: advancedPayment || false,
          advancedAmount: advancedPayment ? Number(advancedAmount) || 0 : 0,
          remainingAmount: advancedPayment ? Number(remainingAmount) || 0 : 0,
          payments: payments || {
            hotels: { officeName: "", price: 0 },
            transfers: { officeName: "", price: 0 },
            trips: { officeName: "", price: 0 },
            flights: { officeName: "", price: 0 },
            others: { officeName: "", price: 0 },
          },
          createdBy: req.user.userId,
        });

        await voucher.save();

        // Automatically create office payment for this voucher
        await manageVoucherOfficePayment(voucher, null, req.user.userId);

        // Smart cache invalidation - voucher data changed
        await invalidateDashboardCache("New voucher created");

        return res.status(201).json({
          success: true,
          data: voucher,
        });
      } catch (retryError) {}
    }

    res.status(500).json({
      success: false,
      message: "Failed to create voucher",
      error: error.message,
    });
  }
};

// Get active vouchers (status: await)
exports.getActiveVouchers = async (req, res) => {
  try {
    const { userId, isAdmin, isAccountant } = req.user;

    // First, update statuses for all vouchers based on arrival dates
    await Voucher.updateAllStatuses();

    let query = {
      $or: [{ isDeleted: false }, { isDeleted: { $exists: false } }],
      status: "await",
    };

    // For regular users, only show their own vouchers
    if (!isAdmin && !isAccountant) {
      query.createdBy = userId;
    }

    const vouchers = await Voucher.find(query)
      .sort({ arrivalDate: 1 }) // Sort by arrival date ascending for active vouchers
      .populate("createdBy", "username")
      .select(
        "voucherNumber clientName nationality arrivalDate departureDate totalAmount currency capital officeName createdBy createdAt"
      );

    res.json({ data: vouchers });
  } catch (err) {
    console.error("Error fetching active vouchers:", err);
    res.status(500).json({ message: "Error fetching active vouchers" });
  }
};

// Get recent vouchers (optimized for widgets)
exports.getRecentVouchers = async (req, res) => {
  try {
    const { limit = 5 } = req.query;
    const { userId, isAdmin, isAccountant } = req.user;

    // Build query based on user permissions
    const query = {
      $or: [{ isDeleted: false }, { isDeleted: { $exists: false } }],
    };

    // Non-admins and non-accountants only see their own vouchers
    if (!isAdmin && !isAccountant) {
      query.createdBy = userId;
    }

    const vouchers = await Voucher.find(query)
      .select(
        "voucherNumber clientName status arrivalDate totalAmount currency createdBy createdAt"
      )
      .populate("createdBy", "username")
      .sort({ createdAt: -1 })
      .limit(parseInt(limit))
      .lean();

    res.json({
      success: true,
      data: vouchers,
    });
  } catch (error) {
    console.error("Error fetching recent vouchers:", error);
    res.status(500).json({
      success: false,
      message: "Failed to fetch recent vouchers",
      error: error.message,
    });
  }
};

// Get vouchers metadata (for filter dropdowns)
exports.getVouchersMetadata = async (req, res) => {
  try {
    const { userId, isAdmin, isAccountant } = req.user;

    // Build query based on user permissions
    const query = {
      $or: [{ isDeleted: false }, { isDeleted: { $exists: false } }],
    };

    // Non-admins and non-accountants only see their own vouchers
    if (!isAdmin && !isAccountant) {
      query.createdBy = userId;
    }

    // Get unique values for dropdowns (lightweight aggregations)
    const [uniqueUsers, uniqueOffices, creationYears, arrivalYears] =
      await Promise.all([
        // Unique users
        Voucher.find(query)
          .distinct("createdBy")
          .then((userIds) =>
            require("../models/User")
              .find({ _id: { $in: userIds } })
              .select("_id username")
              .sort({ username: 1 })
              .lean()
          ),

        // Unique offices
        Voucher.distinct("officeName", {
          ...query,
          officeName: { $exists: true, $ne: "" },
        }).then((offices) => offices.sort()),

        // Creation years
        Voucher.aggregate([
          { $match: query },
          {
            $group: {
              _id: { $year: "$createdAt" },
            },
          },
          { $sort: { _id: -1 } },
        ]).then((results) => results.map((r) => r._id)),

        // Arrival years
        Voucher.aggregate([
          { $match: { ...query, arrivalDate: { $exists: true, $ne: null } } },
          {
            $group: {
              _id: { $year: "$arrivalDate" },
            },
          },
          { $sort: { _id: -1 } },
        ]).then((results) => results.map((r) => r._id)),
      ]);

    res.json({
      success: true,
      data: {
        users: uniqueUsers,
        offices: uniqueOffices,
        creationYears,
        arrivalYears,
      },
    });
  } catch (error) {
    console.error("Error fetching vouchers metadata:", error);
    res.status(500).json({
      success: false,
      message: "Failed to fetch vouchers metadata",
      error: error.message,
    });
  }
};

// Get vouchers list (optimized for VouchersPage with server-side filtering)
exports.getVouchersList = async (req, res) => {
  try {
    const { userId, isAdmin, isAccountant } = req.user;
    const {
      month,
      year,
      arrivalMonth,
      arrivalYear,
      status,
      office,
      createdBy,
    } = req.query;

    // Build query based on user permissions
    const query = {
      $or: [{ isDeleted: false }, { isDeleted: { $exists: false } }],
    };

    // Non-admins and non-accountants only see their own vouchers
    if (!isAdmin && !isAccountant) {
      query.createdBy = userId;
    }

    // Apply creation year filter
    if (year) {
      const yearNum = parseInt(year);
      const yearStart = new Date(yearNum, 0, 1);
      const yearEnd = new Date(yearNum, 11, 31, 23, 59, 59, 999);
      query.createdAt = { $gte: yearStart, $lte: yearEnd };
    }

    // Apply creation month filter (requires year to be set)
    if (month && year) {
      const yearNum = parseInt(year);
      const monthNum = parseInt(month) - 1; // Convert to 0-based
      const monthStart = new Date(yearNum, monthNum, 1);
      const monthEnd = new Date(yearNum, monthNum + 1, 0, 23, 59, 59, 999);
      query.createdAt = { $gte: monthStart, $lte: monthEnd };
    }

    // Apply arrival year filter
    if (arrivalYear) {
      const arrivalYearNum = parseInt(arrivalYear);
      const arrivalYearStart = new Date(arrivalYearNum, 0, 1);
      const arrivalYearEnd = new Date(arrivalYearNum, 11, 31, 23, 59, 59, 999);
      query.arrivalDate = { $gte: arrivalYearStart, $lte: arrivalYearEnd };
    }

    // Apply arrival month filter
    if (arrivalMonth) {
      const arrivalMonthNum = parseInt(arrivalMonth) - 1; // Convert to 0-based

      if (arrivalYear) {
        // Both month and year specified - filter for specific month in specific year
        const arrivalYearNum = parseInt(arrivalYear);
        const arrivalMonthStart = new Date(arrivalYearNum, arrivalMonthNum, 1);
        const arrivalMonthEnd = new Date(
          arrivalYearNum,
          arrivalMonthNum + 1,
          0,
          23,
          59,
          59,
          999
        );
        query.arrivalDate = { $gte: arrivalMonthStart, $lte: arrivalMonthEnd };
      } else {
        // Only month specified - filter for that month across all years
        query.$expr = {
          $eq: [{ $month: "$arrivalDate" }, arrivalMonthNum + 1], // MongoDB months are 1-based
        };
      }
    }

    // Apply status filter
    if (status) {
      query.status = status;
    }

    // Apply office filter
    if (office) {
      query.officeName = office;
    }

    // Apply createdBy filter
    if (createdBy) {
      query.createdBy = createdBy;
    }

    // Fetch only essential fields needed for the list view
    const vouchers = await Voucher.find(query)
      .select(
        "voucherNumber clientName nationality officeName status arrivalDate departureDate capital totalAmount currency createdAt createdBy"
      )
      .populate("createdBy", "username _id")
      .sort({ createdAt: -1 })
      .lean();

    res.json({
      success: true,
      count: vouchers.length,
      data: vouchers,
    });
  } catch (error) {
    console.error("Error fetching vouchers list:", error);
    res.status(500).json({
      success: false,
      message: "Failed to fetch vouchers list",
      error: error.message,
    });
  }
};

// Get vouchers for financial calculations (optimized - only necessary fields, no filters)
exports.getVouchersForFinancials = async (req, res) => {
  try {
    const { userId, isAdmin, isAccountant } = req.user;

    // Build query based on user permissions only
    const query = {
      $or: [{ isDeleted: false }, { isDeleted: { $exists: false } }],
    };

    // Non-admins and non-accountants only see their own vouchers
    if (!isAdmin && !isAccountant) {
      query.createdBy = userId;
    }

    // Fetch only fields needed for financial calculations
    // No currency/date filters - all filtering done on frontend
    const vouchers = await Voucher.find(query)
      .select(
        "_id voucherNumber clientName officeName currency totalAmount capital createdAt " +
          "hotels.officeName hotels.price " +
          "transfers.officeName transfers.price " +
          "trips.officeName trips.price " +
          "flights.officeName flights.price " +
          "others.officeName others.price " +
          "payments"
      )
      .sort({ createdAt: -1 })
      .lean();

    res.json({
      success: true,
      count: vouchers.length,
      data: vouchers,
    });
  } catch (error) {
    console.error("Error fetching vouchers for financials:", error);
    res.status(500).json({
      success: false,
      message: "Failed to fetch vouchers for financials",
      error: error.message,
    });
  }
};

// Get upcoming events (optimized for widgets)
exports.getUpcomingEvents = async (req, res) => {
  try {
    const { userId, isAdmin, isAccountant } = req.user;

    // Calculate date ranges
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const next7Days = new Date(today);
    next7Days.setDate(next7Days.getDate() + 7);
    next7Days.setHours(23, 59, 59, 999);

    // Build query based on user permissions
    const baseQuery = {
      $or: [{ isDeleted: false }, { isDeleted: { $exists: false } }],
      status: { $in: ["await", "arrived"] },
    };

    // Non-admins and non-accountants only see their own vouchers
    if (!isAdmin && !isAccountant) {
      baseQuery.createdBy = userId;
    }

    // Fetch departures and arrivals in parallel with optimized queries
    const [departures, arrivals] = await Promise.all([
      // Departures in next 7 days
      Voucher.find({
        ...baseQuery,
        departureDate: { $gte: today, $lte: next7Days },
      })
        .select("voucherNumber clientName status departureDate arrivalDate")
        .sort({ departureDate: 1 })
        .lean(),

      // Arrivals in next 7 days
      Voucher.find({
        ...baseQuery,
        arrivalDate: { $gte: today, $lte: next7Days },
      })
        .select("voucherNumber clientName status arrivalDate departureDate")
        .sort({ arrivalDate: 1 })
        .lean(),
    ]);

    res.json({
      success: true,
      data: {
        departures,
        arrivals,
      },
    });
  } catch (error) {
    console.error("Error fetching upcoming events:", error);
    res.status(500).json({
      success: false,
      message: "Failed to fetch upcoming events",
      error: error.message,
    });
  }
};

exports.getAllVouchers = async (req, res) => {
  try {
    // First, update statuses for all vouchers based on arrival dates
    await Voucher.updateAllStatuses();

    // Get non-deleted vouchers (including existing vouchers without isDeleted field)
    const vouchers = await Voucher.find({
      $or: [{ isDeleted: false }, { isDeleted: { $exists: false } }],
    })
      .sort({ createdAt: -1 })
      .populate("createdBy", "username")
      .populate("statusUpdatedBy", "username")
      .lean(); // Memory optimization - returns plain objects

    // Get office payments for all vouchers to show payment status
    const OfficePayment = require("../models/OfficePayment");
    const voucherIds = vouchers.map((v) => v._id);
    const officePayments = await OfficePayment.find({
      relatedVoucher: { $in: voucherIds },
    }).lean();

    // Map office payments to vouchers (voucher is already plain object from lean())
    const vouchersWithPayments = vouchers.map((voucher) => {
      const voucherPayments = officePayments.filter(
        (payment) =>
          payment.relatedVoucher &&
          payment.relatedVoucher.toString() === voucher._id.toString()
      );
      return {
        ...voucher,
        officePayments: voucherPayments,
      };
    });

    res.status(200).json({
      success: true,
      count: vouchersWithPayments.length,
      data: vouchersWithPayments,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Failed to get vouchers",
      error: error.message,
    });
  }
};

exports.getVoucherById = async (req, res) => {
  try {
    const voucher = await Voucher.findById(req.params.id)
      .populate("createdBy", "username")
      .populate("statusUpdatedBy", "username");

    if (!voucher) {
      return res.status(404).json({
        success: false,
        message: "Voucher not found",
      });
    }

    // Check and update status if needed
    const statusUpdated = voucher.updateStatusIfNeeded();
    if (statusUpdated) {
      await voucher.save();
    }

    res.status(200).json({
      success: true,
      data: voucher,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Failed to get voucher",
      error: error.message,
    });
  }
};

exports.getVoucherByNumber = async (req, res) => {
  try {
    const voucher = await Voucher.findOne({
      voucherNumber: req.params.number,
    }).populate("createdBy", "username");

    if (!voucher) {
      return res.status(404).json({
        success: false,
        message: "Voucher not found",
      });
    }

    res.status(200).json({
      success: true,
      data: voucher,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Failed to get voucher",
      error: error.message,
    });
  }
};

exports.getNextVoucherNumber = async (req, res) => {
  try {
    const nextNumber = await Voucher.getNextVoucherNumber();

    res.status(200).json({
      success: true,
      nextNumber,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Failed to get next voucher number",
      error: error.message,
    });
  }
};

// Soft delete voucher (move to trash)
exports.deleteVoucher = async (req, res) => {
  try {
    const voucher = await Voucher.findById(req.params.id);

    if (!voucher) {
      return res.status(404).json({
        success: false,
        message: "Voucher not found",
      });
    }

    // Only full admins can delete vouchers (not accountants or regular users)
    if (!req.user.isAdmin) {
      return res.status(403).json({
        success: false,
        message: "Only administrators are authorized to delete vouchers",
      });
    }

    // Accountants cannot delete vouchers even if they created them
    if (req.user.isAccountant && !req.user.isAdmin) {
      return res.status(403).json({
        success: false,
        message: "Accountants are not authorized to delete vouchers",
      });
    }

    // Delete only pending auto-generated office payments for this voucher
    // Approved payments are preserved as they've been finalized
    await OfficePayment.deleteMany({
      relatedVoucher: req.params.id,
      autoGenerated: true,
      status: "pending",
    });

    // Soft delete - move to trash
    await Voucher.findByIdAndUpdate(req.params.id, {
      isDeleted: true,
      deletedAt: new Date(),
      deletedBy: req.user.userId,
    });

    // Smart cache invalidation - voucher deleted
    await invalidateDashboardCache("Voucher deleted");

    res.status(200).json({
      success: true,
      message: "Voucher moved to trash successfully",
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Failed to delete voucher",
      error: error.message,
    });
  }
};

// Get all trashed vouchers
exports.getTrashedVouchers = async (req, res) => {
  try {
    const vouchers = await Voucher.find({ isDeleted: true })
      .sort({ deletedAt: -1 })
      .populate("createdBy", "username")
      .populate("deletedBy", "username");

    res.status(200).json({
      success: true,
      count: vouchers.length,
      data: vouchers,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Failed to get trashed vouchers",
      error: error.message,
    });
  }
};

// Restore voucher from trash
exports.restoreVoucher = async (req, res) => {
  try {
    const voucher = await Voucher.findById(req.params.id);

    if (!voucher) {
      return res.status(404).json({
        success: false,
        message: "Voucher not found",
      });
    }

    if (!voucher.isDeleted) {
      return res.status(400).json({
        success: false,
        message: "Voucher is not in trash",
      });
    }

    // Only full admins can restore vouchers (not accountants or regular users)
    if (!req.user.isAdmin) {
      return res.status(403).json({
        success: false,
        message: "Only administrators are authorized to restore vouchers",
      });
    }

    // Accountants cannot restore vouchers
    if (req.user.isAccountant && !req.user.isAdmin) {
      return res.status(403).json({
        success: false,
        message: "Accountants are not authorized to restore vouchers",
      });
    }

    // Restore voucher
    const restoredVoucher = await Voucher.findByIdAndUpdate(
      req.params.id,
      {
        isDeleted: false,
        deletedAt: null,
        deletedBy: null,
      },
      { new: true }
    );

    // Recreate office payment if needed
    await manageVoucherOfficePayment(restoredVoucher, null, req.user.userId);

    // Smart cache invalidation - voucher restored
    await invalidateDashboardCache("Voucher restored");

    res.status(200).json({
      success: true,
      message: "Voucher restored successfully",
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Failed to restore voucher",
      error: error.message,
    });
  }
};

// Permanently delete voucher
exports.permanentlyDeleteVoucher = async (req, res) => {
  try {
    const voucher = await Voucher.findById(req.params.id);

    if (!voucher) {
      return res.status(404).json({
        success: false,
        message: "Voucher not found",
      });
    }

    if (!voucher.isDeleted) {
      return res.status(400).json({
        success: false,
        message: "Voucher must be in trash before permanent deletion",
      });
    }

    // Only full admins can permanently delete vouchers (not accountants or regular users)
    if (!req.user.isAdmin) {
      return res.status(403).json({
        success: false,
        message:
          "Only administrators are authorized to permanently delete vouchers",
      });
    }

    // Accountants cannot permanently delete vouchers even if they created them
    if (req.user.isAccountant && !req.user.isAdmin) {
      return res.status(403).json({
        success: false,
        message:
          "Accountants are not authorized to permanently delete vouchers",
      });
    }

    // Delete only pending auto-generated office payments for this voucher
    // Approved payments are preserved as they've been finalized
    await OfficePayment.deleteMany({
      relatedVoucher: req.params.id,
      autoGenerated: true,
      status: "pending",
    });

    // Permanently delete
    await Voucher.findByIdAndDelete(req.params.id);

    res.status(200).json({
      success: true,
      message: "Voucher permanently deleted",
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Failed to permanently delete voucher",
      error: error.message,
    });
  }
};

exports.updateVoucher = async (req, res) => {
  try {
    // First check if the voucher exists and if the user is authorized
    const voucher = await Voucher.findById(req.params.id);

    if (!voucher) {
      return res.status(404).json({
        success: false,
        message: "Voucher not found",
      });
    }

    // Check if the user is authorized to update the voucher
    if (!req.user.isAdmin && voucher.createdBy.toString() !== req.user.userId) {
      return res.status(403).json({
        success: false,
        message: "You are not authorized to update this voucher",
      });
    }

    const {
      clientName,
      nationality,
      phoneNumber,
      officeName,
      bookingReference,
      arrivalDate,
      departureDate,
      capital,
      hotels,
      transfers,
      trips,
      flights,
      others,
      note,
      privateNote,
      totalAmount,
      currency,
      advancedPayment,
      advancedAmount,
      remainingAmount,
      payments,
    } = req.body;

    // Store old voucher data for payment management
    const oldVoucherData = {
      officeName: voucher.officeName,
      totalAmount: voucher.totalAmount,
      currency: voucher.currency,
      _id: voucher._id,
    };

    // Find and update the voucher
    const updatedVoucher = await Voucher.findByIdAndUpdate(
      req.params.id,
      {
        clientName,
        nationality,
        phoneNumber: phoneNumber || "",
        officeName: officeName || "",
        bookingReference: bookingReference || "Auto-generated",
        arrivalDate,
        departureDate,
        capital: capital || "",
        currency: currency || "USD",
        hotels,
        transfers,
        trips,
        flights: flights || [],
        others: others || [],
        note: note || "",
        privateNote: privateNote || "",
        totalAmount: Number(totalAmount) || 0,
        advancedPayment: advancedPayment || false,
        advancedAmount: advancedPayment ? Number(advancedAmount) || 0 : 0,
        remainingAmount: advancedPayment ? Number(remainingAmount) || 0 : 0,
        payments: payments || {
          hotels: { officeName: "", price: 0 },
          transfers: { officeName: "", price: 0 },
          trips: { officeName: "", price: 0 },
          flights: { officeName: "", price: 0 },
          others: { officeName: "", price: 0 },
        },
      },
      { new: true, runValidators: true }
    ).populate("createdBy", "username");

    if (!updatedVoucher) {
      return res.status(404).json({
        success: false,
        message: "Voucher not found",
      });
    }

    // Note: We don't regenerate auto-payments on edit to preserve existing payment history
    // Auto-payments are only generated on voucher creation

    // Smart cache invalidation - voucher data changed
    await invalidateDashboardCache("Voucher updated");

    res.status(200).json({
      success: true,
      data: updatedVoucher,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Failed to update voucher",
      error: error.message,
    });
  }
};

exports.updateVoucherStatus = async (req, res) => {
  try {
    const { status } = req.body;
    const voucherId = req.params.id;

    if (!status || !["await", "arrived", "canceled"].includes(status)) {
      return res.status(400).json({
        success: false,
        message: "Invalid status. Must be one of: await, arrived, canceled",
      });
    }

    const voucher = await Voucher.findById(voucherId);
    if (!voucher) {
      return res.status(404).json({
        success: false,
        message: "Voucher not found",
      });
    }

    if (voucher.isDeleted) {
      return res.status(400).json({
        success: false,
        message: "Cannot update status of deleted voucher",
      });
    }

    if (!req.user.isAdmin && !req.user.isAccountant) {
      return res.status(403).json({
        success: false,
        message:
          "Only administrators and accountants can update voucher status",
      });
    }

    if (status === "arrived") {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const arrivalDate = new Date(voucher.arrivalDate);
      arrivalDate.setHours(0, 0, 0, 0);

      if (arrivalDate > today) {
        return res.status(400).json({
          success: false,
          message: 'Cannot set status to "arrived" before the arrival date',
        });
      }
    }

    const updatedVoucher = await Voucher.findByIdAndUpdate(
      voucherId,
      {
        status: status,
        statusUpdatedBy: req.user.userId,
        statusUpdatedAt: new Date(),
      },
      { new: true, runValidators: true }
    )
      .populate("createdBy", "username")
      .populate("statusUpdatedBy", "username");

    // Smart cache invalidation - voucher status changed
    await invalidateDashboardCache("Voucher status updated");

    res.status(200).json({
      success: true,
      message: `Voucher status updated to "${status}"`,
      data: updatedVoucher,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Failed to update voucher status",
      error: error.message,
    });
  }
};

// Update voucher's created by user (Admin only)
exports.updateVoucherCreatedBy = async (req, res) => {
  try {
    const { createdBy } = req.body;
    const voucherId = req.params.id;

    if (!req.user.isAdmin) {
      return res.status(403).json({
        success: false,
        message: "Only administrators can update voucher ownership",
      });
    }
    if (!createdBy) {
      return res.status(400).json({
        success: false,
        message: "Created by user ID is required",
      });
    }
    const voucher = await Voucher.findById(voucherId);
    if (!voucher) {
      return res.status(404).json({
        success: false,
        message: "Voucher not found",
      });
    }
    if (voucher.isDeleted) {
      return res.status(400).json({
        success: false,
        message: "Cannot update deleted voucher",
      });
    }
    const User = require("../models/User");
    const newCreatedByUser = await User.findById(createdBy).select("username");
    if (!newCreatedByUser) {
      return res.status(400).json({
        success: false,
        message: "Specified user not found",
      });
    }
    const updatedVoucher = await Voucher.findByIdAndUpdate(
      voucherId,
      { createdBy: createdBy },
      { new: true, runValidators: true }
    )
      .populate("createdBy", "username")
      .populate("statusUpdatedBy", "username");

    res.status(200).json({
      success: true,
      message: `Voucher ownership transferred to "${newCreatedByUser.username}"`,
      data: updatedVoucher,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Failed to update voucher ownership",
      error: error.message,
    });
  }
};

// Update voucher payment date (Admin/Accountant only)
exports.updateVoucherPaymentDate = async (req, res) => {
  try {
    const { paymentDate } = req.body;
    const voucherId = req.params.id;

    // Check if user is admin or accountant
    if (!req.user.isAdmin && !req.user.isAccountant) {
      return res.status(403).json({
        success: false,
        message: "Only administrators and accountants can update payment dates",
      });
    }

    if (!paymentDate) {
      return res.status(400).json({
        success: false,
        message: "Payment date is required",
      });
    }

    const voucher = await Voucher.findById(voucherId);
    if (!voucher) {
      return res.status(404).json({
        success: false,
        message: "Voucher not found",
      });
    }

    if (voucher.isDeleted) {
      return res.status(400).json({
        success: false,
        message: "Cannot update payment date of deleted voucher",
      });
    }

    // Update the voucher's payment date
    const updatedVoucher = await Voucher.findByIdAndUpdate(
      voucherId,
      { paymentDate: new Date(paymentDate) },
      { new: true, runValidators: true }
    )
      .populate("createdBy", "username")
      .populate("statusUpdatedBy", "username");

    // Also update the payment date for any related office payments
    await OfficePayment.updateMany(
      { relatedVoucher: voucherId },
      { paymentDate: new Date(paymentDate) }
    );

    res.status(200).json({
      success: true,
      message: "Payment date updated successfully",
      data: updatedVoucher,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Failed to update payment date",
      error: error.message,
    });
  }
};
