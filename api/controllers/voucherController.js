const Voucher = require('../models/Voucher');
const OfficePayment = require('../models/OfficePayment');
const { invalidateDashboardCache } = require('../utils/redis');

// Helper function to manage automatic office payments for vouchers
const manageVoucherOfficePayment = async (voucher, oldVoucher = null, userId) => {
    try {
        // First, delete all existing auto-generated payments for this voucher
        await OfficePayment.deleteMany({
            relatedVoucher: voucher._id,
            autoGenerated: true
        });

        // PRIORITY 1: Client-level office payment (main voucher payment)
        // If voucher has an officeName and totalAmount, create client payment
        if (voucher.officeName && voucher.officeName.trim() !== '' && voucher.totalAmount > 0) {
            const clientPayment = new OfficePayment({
                type: 'INCOMING',
                amount: voucher.totalAmount,
                currency: voucher.currency,
                notes: `Auto-generated client payment from Voucher #${voucher.voucherNumber} - ${voucher.clientName}. Total voucher amount.`,
                officeName: voucher.officeName,
                createdBy: userId,
                relatedVoucher: voucher._id,
                autoGenerated: true,
                status: 'pending'
            });

            await clientPayment.save();
        }

        // PRIORITY 2: Service-level payments (for B2B scenarios)
        // Create service payments regardless of client-level office
        // This allows both client payments AND service payments to coexist
        const servicePayments = [];

        // Hotels
        if (voucher.hotels) {
            voucher.hotels.forEach((hotel, index) => {
                if (hotel.officeName && hotel.price > 0) {
                    servicePayments.push({
                        officeName: hotel.officeName,
                        amount: hotel.price,
                        serviceType: 'hotel',
                        serviceIndex: index,
                        serviceDescription: `${hotel.hotelName || 'Hotel'} - ${hotel.city || 'N/A'}`
                    });
                }
            });
        }

        // Transfers
        if (voucher.transfers) {
            voucher.transfers.forEach((transfer, index) => {
                if (transfer.officeName && transfer.price > 0) {
                    servicePayments.push({
                        officeName: transfer.officeName,
                        amount: transfer.price,
                        serviceType: 'transfer',
                        serviceIndex: index,
                        serviceDescription: `${transfer.type} Transfer - ${transfer.from || 'N/A'} to ${transfer.to || 'N/A'}`
                    });
                }
            });
        }

        // Trips - handle both individual trip payments and global payments.trips
        let tripsHandled = false;
        
        // First, try to extract individual trip payments if trips is an array with payment info
        if (voucher.trips && Array.isArray(voucher.trips)) {
            voucher.trips.forEach((trip, index) => {
                if (trip && typeof trip === 'object' && trip.officeName && trip.price > 0) {
                    servicePayments.push({
                        officeName: trip.officeName,
                        amount: trip.price,
                        serviceType: 'trip',
                        serviceIndex: index,
                        serviceDescription: `${trip.tourName || 'Trip'} - ${trip.city || 'N/A'}`
                    });
                    tripsHandled = true;
                }
            });
        }
        
        // If no individual trip payments found, fall back to global payments.trips
        if (!tripsHandled && voucher.payments && voucher.payments.trips && voucher.payments.trips.officeName && voucher.payments.trips.price > 0) {
            servicePayments.push({
                officeName: voucher.payments.trips.officeName,
                amount: voucher.payments.trips.price,
                serviceType: 'trip',
                serviceIndex: 0,
                serviceDescription: 'Trip Services'
            });
        }

        // Flights
        if (voucher.flights) {
            voucher.flights.forEach((flight, index) => {
                if (flight.officeName && flight.price > 0) {
                    servicePayments.push({
                        officeName: flight.officeName,
                        amount: flight.price,
                        serviceType: 'flight',
                        serviceIndex: index,
                        serviceDescription: `${flight.companyName || 'Flight'} - ${flight.from || 'N/A'} to ${flight.to || 'N/A'}`
                    });
                }
            });
        }

        // Group service payments by office to create consolidated payments
        const officeGroups = {};
        servicePayments.forEach(service => {
            if (!officeGroups[service.officeName]) {
                officeGroups[service.officeName] = {
                    totalAmount: 0,
                    services: []
                };
            }
            officeGroups[service.officeName].totalAmount += service.amount;
            officeGroups[service.officeName].services.push(service);
        });

        // Create service payments for each office
        for (const [officeName, groupData] of Object.entries(officeGroups)) {
            const serviceDescriptions = groupData.services.map(s => s.serviceDescription).join(', ');
            const notes = `Auto-generated service payment from Voucher #${voucher.voucherNumber} - ${voucher.clientName}. Services: ${serviceDescriptions}`;

            const payment = new OfficePayment({
                type: 'OUTGOING',
                amount: groupData.totalAmount,
                currency: voucher.currency,
                notes: notes,
                officeName: officeName,
                createdBy: userId,
                relatedVoucher: voucher._id,
                autoGenerated: true,
                status: 'pending'
            });

            await payment.save();
        }

    } catch (error) {
        console.error('Error managing voucher office payment:', error);
        // Don't throw error here - we don't want voucher creation/update to fail because of payment issues
    }
};

// Create a new voucher
exports.createVoucher = async (req, res) => {
    try {
        const {
            voucherNumber: providedVoucherNumber,
            clientName,
            nationality,
            phoneNumber,
            officeName,
            bookingReference,
            arrivalDate,
            departureDate,
            capital,
            hotels,
            transfers,
            trips,
            flights,
            note,
            totalAmount,
            currency,
            advancedPayment,
            advancedAmount,
            remainingAmount,
            payments
        } = req.body;



        let voucherNumber;
        if (providedVoucherNumber) {
            voucherNumber = providedVoucherNumber;
        } else {
            voucherNumber = await Voucher.getNextVoucherNumber();
        }

        const voucher = new Voucher({
            voucherNumber,
            voucherId: voucherNumber,
            bookingNumber: voucherNumber,
            clientName,
            nationality,
            phoneNumber: phoneNumber || '',
            officeName: officeName || '',
            bookingReference: bookingReference || 'Auto-generated',
            arrivalDate,
            departureDate,
            capital: capital || '',
            currency: currency || 'USD',
            hotels,
            transfers,
            trips,
            flights: flights || [],
            note: note || '',
            totalAmount: Number(totalAmount) || 0,
            advancedPayment: advancedPayment || false,
            advancedAmount: advancedPayment ? Number(advancedAmount) || 0 : 0,
            remainingAmount: advancedPayment ? Number(remainingAmount) || 0 : 0,
            payments: payments || {
                hotels: { officeName: '', price: 0 },
                transfers: { officeName: '', price: 0 },
                trips: { officeName: '', price: 0 },
                flights: { officeName: '', price: 0 }
            },
            createdBy: req.user.userId
        });
        
        await voucher.save();
        
        // Automatically create office payment for this voucher
        await manageVoucherOfficePayment(voucher, null, req.user.userId);
        
        // Smart cache invalidation - voucher data changed
        await invalidateDashboardCache('New voucher created');
        
        res.status(201).json({
            success: true,
            data: voucher
        });
    } catch (error) {
        if (error.code === 11000) {            
            try {
                const randomNumber = 10000 + Math.floor(Math.random() * 90000);
                
                const voucher = new Voucher({
                    voucherNumber: randomNumber,
                    voucherId: randomNumber,
                    bookingNumber: randomNumber,
                    clientName,
                    nationality,
                    phoneNumber: phoneNumber || '',
                    officeName: officeName || '',
                    bookingReference: bookingReference || 'Auto-generated',
                    arrivalDate,
                    departureDate,
                    capital: capital || '',
                    currency: currency || 'USD',
                    hotels,
                    transfers,
                    trips,
                    flights: flights || [],
                    note: note || '',
                    totalAmount: Number(totalAmount) || 0,
                    advancedPayment: advancedPayment || false,
                    advancedAmount: advancedPayment ? Number(advancedAmount) || 0 : 0,
                    remainingAmount: advancedPayment ? Number(remainingAmount) || 0 : 0,
                    payments: payments || {
                        hotels: { officeName: '', price: 0 },
                        transfers: { officeName: '', price: 0 },
                        trips: { officeName: '', price: 0 },
                        flights: { officeName: '', price: 0 }
                    },
                    createdBy: req.user.userId
                });
                
                await voucher.save();
                
                // Automatically create office payment for this voucher
                await manageVoucherOfficePayment(voucher, null, req.user.userId);
                
                // Smart cache invalidation - voucher data changed
                await invalidateDashboardCache('New voucher created');
                
                return res.status(201).json({
                    success: true,
                    data: voucher
                });
            } catch (retryError) {

            }
        }
        
        res.status(500).json({
            success: false,
            message: 'Failed to create voucher',
            error: error.message
        });
    }
};

// Get active vouchers (status: await)
exports.getActiveVouchers = async (req, res) => {
    try {
        const { userId, isAdmin, isAccountant } = req.user;
        
        // First, update statuses for all vouchers based on arrival dates
        await Voucher.updateAllStatuses();
        
        let query = {
            $or: [
                { isDeleted: false },
                { isDeleted: { $exists: false } }
            ],
            status: 'await'
        };
        
        // For regular users, only show their own vouchers
        if (!isAdmin && !isAccountant) {
            query.createdBy = userId;
        }
        
        const vouchers = await Voucher.find(query)
            .sort({ arrivalDate: 1 }) // Sort by arrival date ascending for active vouchers
            .populate('createdBy', 'username')
            .select('voucherNumber clientName nationality arrivalDate departureDate totalAmount currency capital officeName createdBy createdAt');
        
        res.json({ data: vouchers });
        
    } catch (err) {
        console.error('Error fetching active vouchers:', err);
        res.status(500).json({ message: 'Error fetching active vouchers' });
    }
};

exports.getAllVouchers = async (req, res) => {
    try {
        // First, update statuses for all vouchers based on arrival dates
        await Voucher.updateAllStatuses();
        
        // Get non-deleted vouchers (including existing vouchers without isDeleted field)
        const vouchers = await Voucher.find({ 
            $or: [
                { isDeleted: false },
                { isDeleted: { $exists: false } }
            ]
        })
            .sort({ createdAt: -1 })
            .populate('createdBy', 'username')
            .populate('statusUpdatedBy', 'username');
        
        // Get office payments for all vouchers to show payment status
        const OfficePayment = require('../models/OfficePayment');
        const voucherIds = vouchers.map(v => v._id);
        const officePayments = await OfficePayment.find({ 
            relatedVoucher: { $in: voucherIds } 
        });
        
        // Map office payments to vouchers
        const vouchersWithPayments = vouchers.map(voucher => {
            const voucherPayments = officePayments.filter(payment => 
                payment.relatedVoucher && payment.relatedVoucher.toString() === voucher._id.toString()
            );
            return {
                ...voucher.toObject(),
                officePayments: voucherPayments
            };
        });
        
        res.status(200).json({
            success: true,
            count: vouchersWithPayments.length,
            data: vouchersWithPayments
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Failed to get vouchers',
            error: error.message
        });
    }
};

exports.getVoucherById = async (req, res) => {
    try {
        const voucher = await Voucher.findById(req.params.id)
            .populate('createdBy', 'username')
            .populate('statusUpdatedBy', 'username');
        
        if (!voucher) {
            return res.status(404).json({
                success: false,
                message: 'Voucher not found'
            });
        }
        
        // Check and update status if needed
        const statusUpdated = voucher.updateStatusIfNeeded();
        if (statusUpdated) {
            await voucher.save();
        }
        
        res.status(200).json({
            success: true,
            data: voucher
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Failed to get voucher',
            error: error.message
        });
    }
};


exports.getVoucherByNumber = async (req, res) => {
    try {
        const voucher = await Voucher.findOne({ voucherNumber: req.params.number })
            .populate('createdBy', 'username');
        
        if (!voucher) {
            return res.status(404).json({
                success: false,
                message: 'Voucher not found'
            });
        }
        
        res.status(200).json({
            success: true,
            data: voucher
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Failed to get voucher',
            error: error.message
        });
    }
};

exports.getNextVoucherNumber = async (req, res) => {
    try {
        const nextNumber = await Voucher.getNextVoucherNumber();
        
        res.status(200).json({
            success: true,
            nextNumber
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Failed to get next voucher number',
            error: error.message
        });
    }
};

// Soft delete voucher (move to trash)
exports.deleteVoucher = async (req, res) => {
    try {
        const voucher = await Voucher.findById(req.params.id);
        
        if (!voucher) {
            return res.status(404).json({
                success: false,
                message: 'Voucher not found'
            });
        }
        
        // Only full admins can delete vouchers (not accountants or regular users)
        if (!req.user.isAdmin) {
            return res.status(403).json({
                success: false,
                message: 'Only administrators are authorized to delete vouchers'
            });
        }
        
        // Accountants cannot delete vouchers even if they created them
        if (req.user.isAccountant && !req.user.isAdmin) {
            return res.status(403).json({
                success: false,
                message: 'Accountants are not authorized to delete vouchers'
            });
        }
        
        // Delete any auto-generated office payments for this voucher
        await OfficePayment.deleteMany({
            relatedVoucher: req.params.id,
            autoGenerated: true
        });
        
        // Soft delete - move to trash
        await Voucher.findByIdAndUpdate(req.params.id, {
            isDeleted: true,
            deletedAt: new Date(),
            deletedBy: req.user.userId
        });

        // Smart cache invalidation - voucher deleted
        await invalidateDashboardCache('Voucher deleted');
        
        res.status(200).json({
            success: true,
            message: 'Voucher moved to trash successfully'
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Failed to delete voucher',
            error: error.message
        });
    }
};

// Get all trashed vouchers
exports.getTrashedVouchers = async (req, res) => {
    try {
        const vouchers = await Voucher.find({ isDeleted: true })
            .sort({ deletedAt: -1 })
            .populate('createdBy', 'username')
            .populate('deletedBy', 'username');
        
        res.status(200).json({
            success: true,
            count: vouchers.length,
            data: vouchers
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Failed to get trashed vouchers',
            error: error.message
        });
    }
};

// Restore voucher from trash
exports.restoreVoucher = async (req, res) => {
    try {
        const voucher = await Voucher.findById(req.params.id);
        
        if (!voucher) {
            return res.status(404).json({
                success: false,
                message: 'Voucher not found'
            });
        }
        
        if (!voucher.isDeleted) {
            return res.status(400).json({
                success: false,
                message: 'Voucher is not in trash'
            });
        }
        
        // Only full admins can restore vouchers (not accountants or regular users)
        if (!req.user.isAdmin) {
            return res.status(403).json({
                success: false,
                message: 'Only administrators are authorized to restore vouchers'
            });
        }
        
        // Accountants cannot restore vouchers
        if (req.user.isAccountant && !req.user.isAdmin) {
            return res.status(403).json({
                success: false,
                message: 'Accountants are not authorized to restore vouchers'
            });
        }
        
        // Restore voucher
        const restoredVoucher = await Voucher.findByIdAndUpdate(req.params.id, {
            isDeleted: false,
            deletedAt: null,
            deletedBy: null
        }, { new: true });
        
        // Recreate office payment if needed
        await manageVoucherOfficePayment(restoredVoucher, null, req.user.userId);
        
        // Smart cache invalidation - voucher restored
        await invalidateDashboardCache('Voucher restored');
        
        res.status(200).json({
            success: true,
            message: 'Voucher restored successfully'
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Failed to restore voucher',
            error: error.message
        });
    }
};

// Permanently delete voucher
exports.permanentlyDeleteVoucher = async (req, res) => {
    try {
        const voucher = await Voucher.findById(req.params.id);
        
        if (!voucher) {
            return res.status(404).json({
                success: false,
                message: 'Voucher not found'
            });
        }
        
        if (!voucher.isDeleted) {
            return res.status(400).json({
                success: false,
                message: 'Voucher must be in trash before permanent deletion'
            });
        }
        
        // Only full admins can permanently delete vouchers (not accountants or regular users)
        if (!req.user.isAdmin) {
            return res.status(403).json({
                success: false,
                message: 'Only administrators are authorized to permanently delete vouchers'
            });
        }
        
        // Accountants cannot permanently delete vouchers even if they created them
        if (req.user.isAccountant && !req.user.isAdmin) {
            return res.status(403).json({
                success: false,
                message: 'Accountants are not authorized to permanently delete vouchers'
            });
        }
        
        // Delete any auto-generated office payments for this voucher
        await OfficePayment.deleteMany({
            relatedVoucher: req.params.id,
            autoGenerated: true
        });
        
        // Permanently delete
        await Voucher.findByIdAndDelete(req.params.id);
        
        res.status(200).json({
            success: true,
            message: 'Voucher permanently deleted'
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Failed to permanently delete voucher',
            error: error.message
        });
    }
};

exports.updateVoucher = async (req, res) => {
    try {
        // First check if the voucher exists and if the user is authorized
        const voucher = await Voucher.findById(req.params.id);
        
        if (!voucher) {
            return res.status(404).json({
                success: false,
                message: 'Voucher not found'
            });
        }
        
        // Check if the user is authorized to update the voucher
        if (!req.user.isAdmin && voucher.createdBy.toString() !== req.user.userId) {
            return res.status(403).json({
                success: false,
                message: 'You are not authorized to update this voucher'
            });
        }
        
        const {
            clientName,
            nationality,
            phoneNumber,
            officeName,
            bookingReference,
            arrivalDate,
            departureDate,
            capital,
            hotels,
            transfers,
            trips,
            flights,
            note,
            totalAmount,
            currency,
            advancedPayment,
            advancedAmount,
            remainingAmount,
            payments
        } = req.body;



        // Store old voucher data for payment management
        const oldVoucherData = {
            officeName: voucher.officeName,
            totalAmount: voucher.totalAmount,
            currency: voucher.currency,
            _id: voucher._id
        };

        // Find and update the voucher
        const updatedVoucher = await Voucher.findByIdAndUpdate(
            req.params.id,
            {
                clientName,
                nationality,
                phoneNumber: phoneNumber || '',
                officeName: officeName || '',
                bookingReference: bookingReference || 'Auto-generated',
                arrivalDate,
                departureDate,
                capital: capital || '',
                currency: currency || 'USD',
                hotels,
                transfers,
                trips,
                flights: flights || [],
                note: note || '',
                totalAmount: Number(totalAmount) || 0,
                advancedPayment: advancedPayment || false,
                advancedAmount: advancedPayment ? Number(advancedAmount) || 0 : 0,
                remainingAmount: advancedPayment ? Number(remainingAmount) || 0 : 0,
                payments: payments || {
                    hotels: { officeName: '', price: 0 },
                    transfers: { officeName: '', price: 0 },
                    trips: { officeName: '', price: 0 },
                    flights: { officeName: '', price: 0 }
                }
            },
            { new: true, runValidators: true }
        ).populate('createdBy', 'username');

        if (!updatedVoucher) {
            return res.status(404).json({
                success: false,
                message: 'Voucher not found'
            });
        }

        // Automatically manage office payment for this voucher update
        await manageVoucherOfficePayment(updatedVoucher, oldVoucherData, req.user.userId);

        // Smart cache invalidation - voucher data changed
        await invalidateDashboardCache('Voucher updated');

        res.status(200).json({
            success: true,
            data: updatedVoucher
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Failed to update voucher',
            error: error.message
        });
    }
};

exports.updateVoucherStatus = async (req, res) => {
    try {
        const { status } = req.body;
        const voucherId = req.params.id;
        
        if (!status || !['await', 'arrived', 'canceled'].includes(status)) {
            return res.status(400).json({
                success: false,
                message: 'Invalid status. Must be one of: await, arrived, canceled'
            });
        }

        const voucher = await Voucher.findById(voucherId);
        if (!voucher) {
            return res.status(404).json({
                success: false,
                message: 'Voucher not found'
            });
        }

        if (voucher.isDeleted) {
            return res.status(400).json({
                success: false,
                message: 'Cannot update status of deleted voucher'
            });
        }

        if (!req.user.isAdmin && !req.user.isAccountant) {
            return res.status(403).json({
                success: false,
                message: 'Only administrators and accountants can update voucher status'
            });
        }

        if (status === 'arrived') {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const arrivalDate = new Date(voucher.arrivalDate);
            arrivalDate.setHours(0, 0, 0, 0);
            
            if (arrivalDate > today) {
                return res.status(400).json({
                    success: false,
                    message: 'Cannot set status to "arrived" before the arrival date'
                });
            }
        }
        
        const updatedVoucher = await Voucher.findByIdAndUpdate(
            voucherId,
            {
                status: status,
                statusUpdatedBy: req.user.userId,
                statusUpdatedAt: new Date()
            },
            { new: true, runValidators: true }
        )
        .populate('createdBy', 'username')
        .populate('statusUpdatedBy', 'username');

        // Smart cache invalidation - voucher status changed
        await invalidateDashboardCache('Voucher status updated');

        res.status(200).json({
            success: true,
            message: `Voucher status updated to "${status}"`,
            data: updatedVoucher
        });
        
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Failed to update voucher status',
            error: error.message
        });
    }
};

// Update voucher's created by user (Admin only)
exports.updateVoucherCreatedBy = async (req, res) => {
    try {
        const { createdBy } = req.body;
        const voucherId = req.params.id;
        

        if (!req.user.isAdmin) {
            return res.status(403).json({
                success: false,
                message: 'Only administrators can update voucher ownership'
            });
        }
        if (!createdBy) {
            return res.status(400).json({
                success: false,
                message: 'Created by user ID is required'
            });
        }
        const voucher = await Voucher.findById(voucherId);
        if (!voucher) {
            return res.status(404).json({
                success: false,
                message: 'Voucher not found'
            });
        }
        if (voucher.isDeleted) {
            return res.status(400).json({
                success: false,
                message: 'Cannot update deleted voucher'
            });
        }
        const User = require('../models/User');
        const newCreatedByUser = await User.findById(createdBy).select('username');
        if (!newCreatedByUser) {
            return res.status(400).json({
                success: false,
                message: 'Specified user not found'
            });
        }
        const updatedVoucher = await Voucher.findByIdAndUpdate(
            voucherId,
            { createdBy: createdBy },
            { new: true, runValidators: true }
        )
        .populate('createdBy', 'username')
        .populate('statusUpdatedBy', 'username');
        
        res.status(200).json({
            success: true,
            message: `Voucher ownership transferred to "${newCreatedByUser.username}"`,
            data: updatedVoucher
        });
        
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Failed to update voucher ownership',
            error: error.message
        });
    }
};

// Update voucher payment date (Admin/Accountant only)
exports.updateVoucherPaymentDate = async (req, res) => {
    try {
        const { paymentDate } = req.body;
        const voucherId = req.params.id;
        
        // Check if user is admin or accountant
        if (!req.user.isAdmin && !req.user.isAccountant) {
            return res.status(403).json({
                success: false,
                message: 'Only administrators and accountants can update payment dates'
            });
        }

        if (!paymentDate) {
            return res.status(400).json({
                success: false,
                message: 'Payment date is required'
            });
        }

        const voucher = await Voucher.findById(voucherId);
        if (!voucher) {
            return res.status(404).json({
                success: false,
                message: 'Voucher not found'
            });
        }

        if (voucher.isDeleted) {
            return res.status(400).json({
                success: false,
                message: 'Cannot update payment date of deleted voucher'
            });
        }

        // Update the voucher's payment date
        const updatedVoucher = await Voucher.findByIdAndUpdate(
            voucherId,
            { paymentDate: new Date(paymentDate) },
            { new: true, runValidators: true }
        )
        .populate('createdBy', 'username')
        .populate('statusUpdatedBy', 'username');

        // Also update the payment date for any related office payments
        await OfficePayment.updateMany(
            { relatedVoucher: voucherId },
            { paymentDate: new Date(paymentDate) }
        );
        
        res.status(200).json({
            success: true,
            message: 'Payment date updated successfully',
            data: updatedVoucher
        });
        
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Failed to update payment date',
            error: error.message
        });
    }
}; 